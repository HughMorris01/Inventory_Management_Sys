package controller;

import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.stage.Stage;
import model.Inventory;
import model.Part;
import model.Product;

import java.io.IOException;
import java.net.URL;
import java.util.Optional;
import java.util.ResourceBundle;

/** This class is the controller file for the ModifyProductScreen FXML document and not meant to be instantiated.
 * The class is initially passed a Product object from the Inventory Main Screen and uses that to populate the text
 * fields and table with the object's associated data fields. The user can then update those values and create a new
 * Product object, which replaces the passed Product in the static observable list of Products in the Inventory.
 * class.
 * @author Greg Farrell
 * @version 1.0
 */
public class ModifyProductScreenController implements Initializable {

    /** Disabled text field for the product ID, which is autogenerated. */
    public TextField idTextField;
    /** Product name text field */
    public TextField nameTextField;
    /** Product maximum text field */
    public TextField maxTextField;
    /** Product minimum text field */
    public TextField minTextField;
    /** Product stock text field */
    public TextField inventoryTextField;
    /** Product price text field */
    public TextField priceTextField;
    /** Parts tableview */
    public TableView<Part> partTable;
    /** Parts ID column */
    public TableColumn<Part, Integer> partIdCol;
    /** Parts Name column */
    public TableColumn<Part, String> partNameCol;
    /** Parts Inventory column */
    public TableColumn<Part, Integer> partInventoryCol;
    /** Parts price column */
    public TableColumn<Part, Double> partPriceCol;
    /** Associated parts tableview */
    public TableView<Part> associatedPartsTable;
    /** Associated parts ID column */
    public TableColumn<Part, Integer> associatedPartIdCol;
    /** Associated parts name column */
    public TableColumn<Part, String> associatedPartNameCol;
    /** Associated parts stock column */
    public TableColumn<Part, Integer> associatedPartInventoryCol;
    /** Associated parts price column */
    public TableColumn<Part, Double> associatedPartPriceCol;
    /** Parts table search text field */
    public TextField partSearchTextField;

    /** Static Product member used to receive a Product object passed from the Inventory Main Screen */
    protected static Product tempProduct;
    /** Static int member used to store the static Product member's index in the static observable list in the Inventory class */
    protected static int tempProductIndex;

    /** This method is called by the FXMLLoader.load() call contained in the toModifyProduct() method of the InventoryMainScreeController class.
     * The method also takes the static Product that was passed from the Inventory Main Screen and uses it to populate
     * the various text fields. It also initializes and populates two tables, one containing all the parts within the
     * static observable list of parts in the Inventory class and the other with the associated parts (if any) of this
     * product.
     * @param resourceBundle An unreferenced ResourceBundle object passed automatically
     * @param url An unreferenced URL object passed automatically
     */
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {

        idTextField.setText(String.valueOf(tempProduct.getId()));
        nameTextField.setText(tempProduct.getName());
        inventoryTextField.setText(String.valueOf(tempProduct.getStock()));
        priceTextField.setText(String.valueOf(tempProduct.getPrice()));
        minTextField.setText(String.valueOf(tempProduct.getMin()));
        maxTextField.setText(String.valueOf(tempProduct.getMax()));

        partIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        partNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        partInventoryCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        partPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));
        partTable.setItems(Inventory.getAllParts());

        associatedPartIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        associatedPartNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        associatedPartInventoryCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        associatedPartPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));
        associatedPartsTable.setItems(tempProduct.getAllAssociatedParts());
    }

    /** This method is the event handler for the Add button under the parts table.
     * The method adds a selected Part from the table to the observable list member associated with the selected product.
     * @param actionEvent Passed from the On Action event listener in the ModifyProductScreen FXML document
     * @see Product#addAssociatedPart(Part)
     */
    public void addPart(ActionEvent actionEvent) {
        Part part = partTable.getSelectionModel().getSelectedItem();
        tempProduct.addAssociatedPart(part);
    }

    /** This method is the event handler for the Remove Associated Part button.
     * The method first creates an alert box to verify that the user does wish to remove the associated part then
     * it deletes the selected part from the observable list member associated with the selected product. A final alert
     * window then confirms the removal has been completed.
     * @param actionEvent Passed from the On Action event listener in the ModifyProductScreen FXML document
     * @see Product#deleteAssociatedPart(Part)
     */
    public void removePart(ActionEvent actionEvent) {
        Part part = associatedPartsTable.getSelectionModel().getSelectedItem();

        Alert alert = new Alert(Alert.AlertType.CONFIRMATION, "Do you wish to remove this associated part?");
        Optional<ButtonType> result = alert.showAndWait();

        if(result.isPresent()  && result.get() == ButtonType.OK) {
            if(tempProduct.deleteAssociatedPart(part)) {
                Alert alert1 = new Alert(Alert.AlertType.INFORMATION);
                alert1.setTitle("Deletion Confirmation");
                alert1.setContentText("Associated part has been removed from this product.");
                alert1.show();
            }
        }
    }

    /** This method is an event handler for the Cancel button that sends the program back to the main screen.
     * The method loads the FXML document for the main inventory screen, passes that to a new scene and then sets the
     * stage with the new scene.
     * @param actionEvent Passed from the On Action event listener in the ModifyProductScreen FXML document
     * @throws IOException The FXMLLoader.load() call will throw this exception if the FXML document can't be found.
     */
    public void backToMain(ActionEvent actionEvent) throws IOException {
        Parent root = FXMLLoader.load(getClass().getResource("/view/InventoryMainScreen.fxml"));
        Stage stage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();
        Scene scene = new Scene(root, 800, 600);
        stage.setTitle("Inventory Main Screen");
        stage.setScene(scene);
        stage.show();
    }

    /** This method is the event handler for the Save button.
     * The method first grabs all the data from the text fields and performs validation checks and exception
     * handling for dealing with invalid input. The Product() constructor is then called to create a new Product object
     * using that data. The observable list used to populate the associated parts table is then looped through, calling
     * addAssociatedPart() method on the new Product, so that the associated parts are added to its own observable list.
     * Finally, the Product is replaced in the static observable list of Products in the Inventory class using the static
     * tempProductIndex that was passed from the Inventory Main Screen when initialize() method was called.
     * @param actionEvent Passed from the On Action event listener in the ModifyProductScreen FXML document
     * @see Product#Product(int, String, double, int, int, int)
     * @see Product#addAssociatedPart(Part)
     */
    public void saveProduct(ActionEvent actionEvent) {
        int id;
        String name;
        double price;
        int stock;
        int min;
        int max;

        try {
            id = tempProduct.getId();
            name = nameTextField.getText();
            price = Double.parseDouble(priceTextField.getText());
            stock = Integer.parseInt(inventoryTextField.getText());
            min = Integer.parseInt(minTextField.getText());
            max = Integer.parseInt(maxTextField.getText());

            if (min > max) {
                Alert alert = new Alert(Alert.AlertType.ERROR);
                alert.setTitle("Invalid Input");
                alert.setContentText("Minimum must be less than or equal to Maximum.");
                alert.show();
                return;
            }

            if ((min > stock) || (stock > max)) {
                Alert alert = new Alert(Alert.AlertType.ERROR);
                alert.setTitle("Invalid Input");
                alert.setContentText("Inventory must be between Minimum and Maximum.");
                alert.show();
                return;
            }

            Product newProduct = new Product (id, name, price, stock, min, max);
            for(int i = 0; i < tempProduct.getAllAssociatedParts().size(); i++) {
                newProduct.addAssociatedPart(tempProduct.getAllAssociatedParts().get(i));
            }
            Inventory.updateProduct(tempProductIndex, newProduct);

            Parent root = FXMLLoader.load(getClass().getResource("/view/InventoryMainScreen.fxml"));
            Stage stage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();
            Scene scene = new Scene(root, 800, 600);
            stage.setTitle("Inventory Main Screen");
            stage.setScene(scene);
            stage.show();

        }
        catch (NumberFormatException | IOException exception) {
            Alert alert = new Alert(Alert.AlertType.ERROR, "Please enter valid values in the input fields");
            alert.setTitle("Invalid Input Type");
            alert.setContentText(exception.getLocalizedMessage());
            alert.show();
        }
    }

    /** This method is an event handler for the Search text field above the Parts table.
     * The method grabs the input entered in the Search box and then calls the static overloaded method lookupPart()
     * from the Inventory class to search for matches within the Inventory class' static observable list of parts. If
     * the input entered is text, a new observable list is populated with all matches containing the input and the list
     * is used to repopulate the table with the search results. If no text matches are found, lookupPart() is called
     * again to check to see if there is an exact int match with a Part ID and, if so, the Parts table is repopulated
     * with the one matching result. If no matches are found for either the text or the int searches then an alert is
     * created advising that no results were found. When the handler is called on a blank search box, the table will
     * repopulate with the full list of Parts from the static observable list in the Inventory class.
     * RUNTIME ERROR: Initially I tried to search for the int ID first and it continued throwing NumberFormatExceptions.
     * In order to fix the problem I decided to search for the text first and if that found parts list was empty then I'd
     * make a new getText() call and parseInt it. Once I implemented it that way it appears to be fully functional.
     * @see Inventory#lookupPart(String)
     * @see Inventory#lookupPart(int)
     * @param actionEvent Passed from the On Action event listener in the ModifyProductScreen FXML document.
     * */
    public void searchParts(ActionEvent actionEvent) {
        try {
            String tempString = partSearchTextField.getText();
            ObservableList<Part> foundParts = Inventory.lookupPart(tempString);

            if (foundParts.size() == 0) {
                int tempInt = Integer.parseInt(partSearchTextField.getText());
                Part tempPart = Inventory.lookupPart(tempInt);

                if (tempPart != null) {
                    foundParts.add(tempPart);
                }
            }
            if (foundParts.isEmpty()) {
                partSearchTextField.setText("");
                Alert alert1 = new Alert(Alert.AlertType.INFORMATION);
                alert1.setTitle("Invalid Input");
                alert1.setContentText("No results found!");
                alert1.show();
                return;
            }
            partTable.setItems(foundParts);
            partSearchTextField.setText("");
        }
        catch (NumberFormatException exception) {
            partSearchTextField.setText("");
            Alert alert1 = new Alert(Alert.AlertType.ERROR);
            alert1.setTitle("Invalid Input");
            alert1.setContentText("No results found!");
            alert1.show();
        }
    }
}
